/*
 * Name:    VehicleSpawner
 * Version: 1.0
 * Author:  Engima
 *
 * Description:
 * Handles all mission vehicle spawns.
 */
using Intrusion.Common;
using Intrusion.Communication;
 
namespace Intrusion.Server
{
	public class VehicleSpawner : IVehicleSpawner
	{
		private fields ["_mVehicleClassNamesConfig" as IVehicleClassNamesConfig, "_mAllIntrusionVehicles" as Array /* of IntrusionVehicle */, "_mMapMarkersConfig" as IMapMarkersConfig];
	
		// Creates a VehicleHandler object.
		public constructor("_vehicleClassNamesConfig" as IVehicleClassNamesConfig, "_mapMarkersConfig" as IMapMarkersConfig) {
			_mVehicleClassNamesConfig = _vehicleClassNamesConfig;
			_mMapMarkersConfig = _mapMarkersConfig;
			
			_mAllIntrusionVehicles = [];
			[_mAllIntrusionVehicles] call PublicVariableHandler.BroadcastIntrusionVehicles;
		};
		
		// Finds a free spawn position around a given position.
		// _markPos (Array): The position where to find a free spawn position.
		// _initialRadius (Scalar): Optional. The initial radius how far from the position that is ok. This
		// value will expand until a position is found.
		private static method FindSpawnPos("_markPos" as Array, ["_initialRadius" as Scalar, 0]) {
			private ["_spawnpos", "_randir", "_extendedRadius", "_randis", "_houses", "_vehicles", "_isFlat", "_danger", "_foundIt", "_tries"];
			[str _this + " VehicleHandler.FindSpawnPos"] call LogHandler.Debug;
			
			_spawnpos = [];
			_foundIt = false;
			_tries = 0;
			_extendedRadius = 0;
			
			while { true } do {
				scopeName "SpawnPosGen";
				
				_randir = floor random 360;
				_randis = _initialRadius + floor random _extendedRadius;
				_spawnpos = [(_markpos select 0) + ((sin _randir) * _randis), (_markpos select 1) + ((cos _randir) * _randis), 0.1];
				_houses = nearestObjects [_spawnpos, ["house","wall"], 50];
				_vehicles = nearestObjects [_spawnpos, ["LandVehicle", "Land_BagBunker_01_Large_green_F", "Land_TTowerBig_2_F"], 20];
				_isFlat = _spawnpos isFlatEmpty [2, -1, 0.5, 10, 0, false, objNull ]; 
				_danger = false;
				{ if (floor(_spawnpos distance getPos _x) < 10) then { _danger=true; }; } forEach _houses;
				{ if (floor(_spawnpos distance getPos _x) < 8) then { _danger=true; }; } forEach _vehicles;
				if (surfaceIsWater _spawnpos) then { _danger=true; };
				if (count _isFlat < 1 ) then { _danger=true; };
				if (!_danger) then { 
					_foundIt = true;
					breakOut "SpawnPosGen"
				};
				_tries = _tries + 1;
				_extendedRadius = _extendedRadius + 1;
				sleep 0.1;
			};
			
			if (!_foundIt) then {
				_spawnPos = [];
			};
			
			_spawnpos		
		};
		
		// Performs the actual spawn and puts the vehicle on a free spot on the ground around the base.
		// _side (Side): The side that the vehicle belongs to.
		// _vehicleClass (String): The class name of the vehicle to spawn.
		// _professionType (ProfesstionType): Optional. The profession type that the vehicle belongs to 
		// (default: ProfessionType.Undefined).
		// _group (Group): Optional. The group that the vehicle belongs to (default: grpNull).
		// _cost (Scalar): Optional. The vehicle's cost in production (default: 0).
		// Returns (IntrusionVehicle): The intrusion vehicle that was spawned.
		private method IntrusionVehicle SpawnVehicle("_side" as Side, "_vehicleClass" as String, ["_professionType" as ProfessionType, ProfessionType.Undefined], ["_group" as Group, grpNull], ["_cost" as Scalar, 0])
		{
			[str _this + " VehicleHandler.SpawnVehicle"] call LogHandler.Debug;
		    private ["_vehicleObj" as Object, "_spawnDir" as Scalar, "_spawnPos" as Array];
		    private ["_intrusionVehicle" as IntrusionVehicle];
		    private ["_markerInfo" as MapMarkerInfo];
		    
		    _markerInfo = [_side] call _mMapMarkersConfig.GetMapMarkerInfo;
		    
			_spawnDir = markerDir _markerInfo.CarParkMarkerName;
		    _spawnPos = [getMarkerPos _markerInfo.CarParkMarkerName, 10] call _self.FindSpawnPos;
		    
		    while {count _spawnPos == 0} do {
		    	_spawnPos = [getMarkerPos _markerInfo.CarParkMarkerName, 10] call _self.FindSpawnPos;
		    };
		    
		    _vehicleObj = _vehicleClass createVehicle [_spawnPos select 0, _spawnPos select 1, 100];
		    _vehicleObj setDir _spawnDir;
		    _vehicleObj setPos [_spawnPos select 0, _spawnPos select 1, 0.1];
		    clearWeaponCargo _vehicleObj;
		    
        	_intrusionVehicle = [_vehicleObj, _side, _professionType, _group, _cost] new IntrusionVehicle;
        	_vehicleObj setVariable ["IntrusionVehicle", _intrusionVehicle, true];
        	_mAllIntrusionVehicles pushBack _intrusionVehicle;
			[_mAllIntrusionVehicles] call PublicVariableHandler.BroadcastIntrusionVehicles;
        	
        	if (_professionType != ProfessionType.Undefined) then {
				["ClientVehicleHandler.GroupLockVehicles", [[_vehicleObj]]] call Remote.Invoke;
        	};
			
		    _intrusionVehicle
		};

		// Spawns a vehicle on a side's car park.
		// _vehicleClass (String): Vehicle class to spawn.
		// _side (Side): The side's carpark on which to spawn the vehicle.
		// Returns (IntrusionVehicle): The spawned Intrusioni vehicle.
		public method IntrusionVehicle SpawnProfessionVehicle("_group" as Group, "_vehicleClass" as String, "_professionType" as ProfessionType, "_cost" as Scalar)
		{
		    private ["_intrusionVehicle" as IntrusionVehicle];
		    [str _this + " VehicleHandler.SpawnVehicleOnCarpark"] call LogHandler.Debug;
		    
		    _intrusionVehicle = [side _group, _vehicleClass, _professionType, _group, _cost] call _self.SpawnVehicle;
        	
		    _intrusionVehicle
		};
		
		// Spawns a free vehicle on a side's car park.
		// _side (Side): The side's carpark on which to spawn the vehicle.
		// Returns (IntrusionVehicle): The spawned Intrusion vehicle.
		public method IntrusionVehicle SpawnFreeVehicle("_side" as Side) {
		    private ["_vehicleClass" as String, "_intrusionVehicle" as IntrusionVehicle];
			
        	["Spawning free vehicle at side " + str _side] call LogHandler.Info;
        	
        	_vehicleClass = selectRandom ([_side, ProfessionType.Undefined] call _mVehicleClassNamesConfig.GetProVehiclesClassNames);
        	_intrusionVehicle = [_side, _vehicleClass] call _self.SpawnVehicle;
        	
        	_intrusionVehicle
		};
		
		// Counts a side's free vehicles at the base.
		// _side (Side): The side to count vehicles for.
		// Returns (Scalar): The number of free vehicles at the side's base.
		public method Scalar CountFreeVehiclesAtBase("_side" as Side) {
			private ["_vehiclesAtBaseCount" as Scalar, "_markerInfo" as MapMarkerInfo];
			
    		_markerInfo = [_side] call _mMapMarkersConfig.GetMapMarkerInfo;
    		_vehiclesAtBaseCount = 0;

			{
	        	private ["_iVehicle" as IntrusionVehicle];
	        	_iVehicle = _x;
	        	
	            if (alive _iVehicle.Vehicle && (((_iVehicle.Vehicle) distance getMarkerPos (_markerInfo.CarParkMarkerName)) < 100) && _iVehicle.OwnerProfession == ProfessionType.Undefined)  then { // TODO: Should not need parenthesis around _iVehicle.Vehicle and _markerConfig.CarParkMarkerName...
	                _vehiclesAtBaseCount = _vehiclesAtBaseCount + 1;
	            };
	        } foreach _mAllIntrusionVehicles as IntrusionVehicle;
	        
	        _vehiclesAtBaseCount
		};

		private method DeleteVehicleWhenEmpty("_vehicle" as Object)
		{
			waitUntil { sleep 5; count units _vehicle == 0 };
			deleteVehicle _vehicle;
		};
		
		// Deletes a profession vehicle belonging to a group from the map and returns the cost relative to the vehicle's damage.
		// _group (Group): The group whose vehicle will be deleted.
		// Returns (Scalar): The production cost of the vehicle.
		public method Scalar DeleteProfessionVehicles("_group" as Group)
		{
			[str _this + "VehicleSpawner.DeleteProfessionVehicles"] call LogHandler.Debug;
			private ["_intrusionVehiclesToKeep" as Array, "_totalCost" as Scalar, "_vehicleCount" as Scalar, "_totalVehicleDamage" as Scalar];
			private ["_returnedCost" as Scalar];
			
			_returnedCost = 0;
			_intrusionVehiclesToKeep = [];
			_totalCost = 0;
			_vehicleCount = 0;
			_totalVehicleDamage = 0;
			
			{
				if (_x.OwnerGroup == _group) then {
					_vehicleCount = _vehicleCount + 1;
					_totalCost = _x.Cost;
					_totalVehicleDamage = damage _x.Vehicle;
					
					[_x.Vehicle] spawn _self.DeleteVehicleWhenEmpty;
				}
				else {
					_intrusionVehiclesToKeep pushBack _x;
				};
			} foreach _mAllIntrusionVehicles as IntrusionVehicle;
			
			_mAllIntrusionVehicles = _intrusionVehiclesToKeep;
			[_mAllIntrusionVehicles] call PublicVariableHandler.BroadcastIntrusionVehicles;
			
			if (_vehicleCount > 0) then {
				_returnedCost = floor (_totalCost * (1 - (_totalVehicleDamage / _vehicleCount)))
			};
			
			_returnedCost
		};
	};
};
